# Sharp Memory LCD (LS013B7DH03) 驱动实现思路

本文档详细说明了基于 STM32F4 的 Sharp Memory LCD 驱动程序的设计与实现逻辑。

## 1. 硬件连接与配置

### 1.1 引脚定义

根据 `main.h` 和 `gpio.c`，硬件连接如下：

| 信号名称             | STM32 引脚 | 描述      | 配置                                             |
| :------------------- | :--------- | :-------- | :----------------------------------------------- |
| **SCS** (CS)   | PA4        | 片选信号  | GPIO Output, 上拉, 空闲高电平 (注意通信时需拉高) |
| **SI** (MOSI)  | PA7        | 数据输入  | SPI1 MOSI (复用推挽)                             |
| **SCLK** (SCK) | PA5        | 时钟信号  | SPI1 SCK (复用推挽)                              |
| **DISP**       | PA6        | 显示开启  | GPIO Output, 下拉, 拉高开启显示                  |
| **EXTCOMIN**   | PA3        | VCOM 信号 | TIM5_CH4 (PWM), 用于防止液晶极化                 |

### 1.2 SPI 配置 (SPI1)

Sharp Memory LCD 使用 **LSB First** 的通信协议，这与许多标准 SPI 设备（MSB First）不同。

* **模式**: Master
* **方向**: 2 Lines (只用 TX)
* **数据大小**: 8 bit
* **时钟极性 (CPOL)**: Low (空闲低电平)
* **时钟相位 (CPHA)**: 1 Edge (第一个边沿采样)
* **NSS**: Soft (软件控制 CS)
* **First Bit**: **LSB First** (关键配置)
* **波特率**: 预分频 32 (约 2.6MHz @ 84MHz APB2)，屏幕最大支持 2MHz，若不稳定可降速。

### 1.3 VCOM 生成 (TIM5 CH4)

Memory LCD 需要一个周期性翻转的信号 (VCOM) 来防止液晶极化导致损坏。

* **频率**: 50Hz (推荐 1Hz - 60Hz)
* **占空比**: 50%
* **实现**: 使用 TIM5 Channel 4 生成硬件 PWM 信号，直接驱动屏幕的 EXTCOMIN 引脚。相比软件翻转，这种方式不占用 CPU 资源且更稳定。

## 2. 软件架构

### 2.1 显存管理

由于屏幕分辨率为 128x128，且为单色 (1 bit/pixel)，我们在内存中开辟一块显存缓冲区：

```c
// 128行 * (128列 / 8位) = 2048 字节
static uint8_t mlcd_buffer[MLCD_HEIGHT][MLCD_WIDTH / 8];
```

* **映射关系**: 字节的每一位对应一个像素。由于 SPI 是 LSB First，字节的 Bit 0 对应最左边的像素，Bit 7 对应最右边。

### 2.2 核心函数实现

#### 2.2.1 初始化 (`MLCD_Init`)

1. 启动 TIM5 PWM 输出，开始生成 VCOM 信号。
2. 拉高 `DISP` 引脚，开启屏幕显示电路。
3. 延时等待屏幕稳定。
4. 调用 `MLCD_Clear` 清空屏幕内容。

实现思路：

1. 启动VCOM信号：Sharp Memory LCD 是一种液晶屏幕，如果直流电长期施加在液晶分子上会造成不可逆的损坏（极化）。因此必须提供一个1Hz-60Hz的交流信号（VCOM）。利用TIM5 Channel4产生一个50Hz的硬件PWM波直接驱动屏幕的EXTCOMIN引脚，省去了软件定时器翻转的开销。
2. 使能显示（DISP)：将DISP引脚拉高。这是屏幕的电源开关，拉高后屏幕电路开始工作。
3. 等待稳定：给予屏幕内部电路驱动时间（通常几毫秒）。
4. 初始清屏：调用MLCD_Clear()确保屏幕显示干净的白色背景，而不是随机噪点。

#### 2.2.2 清屏 (`MLCD_Clear`)

1. **软件层**: 将 `mlcd_buffer` 全部填充为 `0xFF` (白色)。
2. **硬件层**: 发送 "Clear All" 命令 (0x04)。
   * SCS 拉高 -> 发送命令字节 -> 发送 Trailer -> SCS 拉低。
   * **注意**: 即使硬件清屏了，显存缓冲区也必须同步更新，否则下次刷新会覆盖错误数据。

实现思路：

软件层（显存）：将RAM中的mlcd_buffer全部填充为0xFF。在Memory LCD中，位值1代表白色（反色），0代表黑色（不反射）。

硬件层（屏幕）：发送SPI命令0x04（Clear All）。虽然填充显存后刷新也能清屏，但直接发送硬件清屏命令速度更快且更可靠。

时序保护：操作片选信号（SCS）前后加入了微秒级延时，满足建立时间（Setup Time）和保持时间（Hold Time）要求。

#### 2.2.3 屏幕刷新 (`MLCD_Refresh`)

这是驱动的核心，负责将缓冲区数据传输到屏幕。采用 "Update Mode" (0x01)。

**协议流程**:

1. **SCS 拉高** (Setup Time > 6us)
2. **发送命令字节**: `0x01` (Update Mode)
3. **逐行发送**:
   * **行地址**: 1 byte (行号 1-128)
   * **数据**: 16 bytes (128像素)
   * **行尾 Dummy**: 1 byte (0x00)
4. **帧尾 Dummy**: 2 bytes (0x00, 16 bits Trailer)
5. **SCS 拉低** (Hold Time > 2us)

设计目的：将内存中的图像同步到物理屏幕上

实现思路：严格遵循Sharp LS013B7DH03的SPI通信协议：

1. SCS 激活 ：拉高片选，并延时 tsSCS (>6us)。
2. 发送模式 ：发送命令字节 0x01 (Update Mode)。
3. 逐行传输 ：

   1. 行地址 ：发送行号（1-128）。注意：行号也是 LSB First 发送。
   2. 行数据 ：连续发送该行的 16 个字节数据。
   3. 行尾填充 ：发送 1 字节 Dummy (0x00)，这是协议要求的行间隔。
4. 帧尾填充 ：发送 2 字节 Dummy (0x00)，表示帧结束。
5. SCS 关闭 ：

   关键点 ：在发送完所有数据后， 必须延时 thSCS (>2us) 才能拉低 SCS。

**时序优化**:
为了解决“右下角发虚”等时序问题，在操作 SCS 信号前后加入了微秒级延时 (`MLCD_SoftDelay`)，确保满足 spec 要求的建立时间 (tsSCS) 和保持时间 (thSCS)。

#### 2.2.4 绘图操作 (`DrawLine`, `SetPixel`)

* 所有绘图操作只修改 RAM 中的 `mlcd_buffer`，不立即与硬件通信。
* `MLCD_SetPixel`: 根据坐标计算字节索引和位偏移，进行位运算。
  * 白色 (1): `|= (1 << offset)`
  * 黑色 (0): `&= ~(1 << offset)`
* `MLCD_DrawLine`: 使用标准的 Bresenham 算法实现直线绘制。

实现思路：

显存结构：定义了一个二位数组uint8_t mlcd_buffer[128][16]。每行128个像素由16个字节（16*8=128bit）表示。

位映射逻辑：

    1. 字节索引：x / 8 确定像素位于该行的第几个字节。

2. 位偏移 ： x % 8 确定像素位于该字节的第几位。
3. LSB First ：由于 SPI 配置为 LSB First（低位先行），字节的 Bit 0 对应屏幕上最左侧的像素。

颜色操作 ：

- 白色：使用按位或 |= 将对应位置 1。
- 黑色：使用按位与非 &= ~ 将对应位置 0。

我们以一行中的像素为例，假设我们要操作第 0 行（y=0），设置水平方向上的第 **13 个像素**（x=13）为**黑色**（0）。

假设当前显存 `mlcd_buffer[0]` 这一行全是白色（即所有字节都是 `0xFF`，二进制 `11111111`）。

### 1. 计算坐标

* **目标像素**：`x = 13`
* **字节索引**：`13 / 8 = 1`
  * 这意味着该像素位于这一行的**第 2 个字节**（下标从 0 开始：Byte 0, Byte 1...）。
* **位偏移**：`13 % 8 = 5`
  * 这意味着该像素位于该字节的 **Bit 5**。

### 2. 为什么是 Bit 5？（LSB First 的含义）

在 **LSB First**（低位先行）模式下，字节中的位与屏幕像素的对应关系如下：

| 字节位 (Bit)               | 7 |  6  |       5       |  4  |  3  |  2  |  1  | 0 |
| :------------------------- | :-: | :-: | :------------: | :-: | :-: | :-: | :-: | :-: |
| **屏幕像素位置**     | 右 | ... | **x=13** | ... | ... | ... | ... | 左 |
| **在该字节中的偏移** | +7 | +6 |  **+5**  | +4 | +3 | +2 | +1 | +0 |
| **实际 x 坐标**      | 15 | 14 |  **13**  | 12 | 11 | 10 |  9  | 8 |

* Byte 1 负责屏幕上 x=8 到 x=15 的像素。
* Bit 0 对应 x=8
* ...
* **Bit 5 对应 x = 8 + 5 = 13**

### 3. 执行颜色操作

我们要将该像素设为黑色（0）。

* **当前字节值**：`0xFF` (二进制 `11111111`)
* **掩码计算**：
  1. `1 << 5` (1 左移 5 位) = `00100000` (二进制) = `0x20`
  2. 取反 `~(00100000)` = `11011111` (二进制) = `0xDF`
* **位运算 (按位与)**：
  ```c
  mlcd_buffer[0][1] &= ~(1 << 5);
  // 即：
  //   11111111 (原值)
  // & 11011111 (掩码)
  // ------------
  //   11011111 (新值)
  ```

**结果**：该字节变成了 `0xDF`。当这个字节通过 LSB First 发送到屏幕时：

1. 先发 Bit 0 (1, 白) -> x=8
2. ...
3. 发到 **Bit 5 (0, 黑)** -> **x=13**
4. ...
5. 最后发 Bit 7 (1, 白) -> x=15

这样就在屏幕正确的位置显示了一个黑点。

## 3. 关键注意事项

1. **SCS 时序**: 必须严格遵守 SCS 的 Setup 和 Hold 时间，否则会导致最后一帧数据丢失（表现为屏幕特定区域显示异常）。
2. **VCOM 控制**: 必须持续提供 VCOM 信号。若使用软件控制位 (M1)，则每次 SPI 传输都需翻转该位；本项目使用 EXTCOMIN 硬件引脚，软件协议中的 VCOM 位固定为 0 即可。
3. **LSB First**: 确保 SPI 控制器配置为 LSB First，否则需要在软件中手动翻转每个字节的位序。
